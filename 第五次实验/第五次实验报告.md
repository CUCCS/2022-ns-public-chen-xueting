# 第五次实验 基于scapy编写端口扫描器

## 实验目的

- 掌握网络扫描之端口状态探测的基本原理

## 实验环境

- python + [scapy](https://scapy.net/)

## 实验要求

- [x] 禁止探测互联网上的 IP ，严格遵守网络安全相关法律法规
- [x] 完成以下扫描技术的编程实现
  - [x] TCP connect scan / TCP stealth scan
  - [x] TCP Xmas scan / TCP fin scan / TCP null scan
  - [x] UDP scan
- [x] 上述每种扫描技术的实现测试均需要测试端口状态为：`开放`、`关闭` 和 `过滤` 状态时的程序执行结果
- [x] 提供每一次扫描测试的抓包结果并分析与课本中的扫描方法原理是否相符？如果不同，试分析原因；
- [x] 在实验报告中详细说明实验网络环境拓扑、被测试 IP 的端口状态是如何模拟的

## 实验过程

### 基本信息（同实验四）

- 攻击者主机
  - 08:00:27:c2:a3:40
  - 172.16.111.147
- 受害者主机
  - 08:00:27:22:46:4f
  - 172.16.111.124
- 网关
  - 08:00:27:a4:00:86
  - 172.16.111.1
- 注意：本次试验中，attacker作为扫描端，victim作为靶机

### 端口状态模拟

```bash
# 查看防火墙状态
ufw status
# 关闭状态（防火墙关闭）
ufw disable
# 开启状态（防火墙关闭）
systemctl start apache2 #port 80
systemctl start dnsmasq #port 53
# 过滤状态（在开启端口监听的同时开启防火墙）
ufw enable && ufw deny 80/tcp
ufw enable && ufw deny 53/udp
```

### TCP connection scan

- 存储下列代码为可执行的python文件，并在攻击者主机上执行该文件

```python
from scapy.all import *

def tcpconnect(dst_ip, dst_port, timeout=10):
    pkts = sr1(IP(dst=dst_ip)/TCP(dport=dst_port,flags="S"),timeout=timeout)
    if pkts is None:
        print("Filtered")
    elif(pkts.haslayer(TCP)):
        if(pkts.getlayer(TCP).flags == 0x12):  #Flags: 0x012 (SYN, ACK)
            send_rst = sr(IP(dst=dst_ip)/TCP(dport=dst_port,flags="AR"),timeout=timeout)
            print("Open")
        elif (pkts.getlayer(TCP).flags == 0x14):   #Flags: 0x014 (RST, ACK)
            print("Closed")

tcpconnect('172.16.111.124', 80)
```

<img src="img\tcp_connection.png" alt="tcp" style="zoom: 50%;" />

- 端口状态测试

  - 端口关闭 `sudo ufw disable`

    <img src="img\tcp_status.png" alt="status" style="zoom:50%;" />

    <img src="img\wireshark_tcp.png" style="zoom:50%;" />

  - 端口打开`sudo ufw enable && sudo ufw allow 80/tcp`

    ![](img\wireshark_close.png) 

    > 注意，此处抓包接收到了被扫描端的SYN/ACK，且对于扫描端，RST与ACK 同时发出，说明端口已经成功开启。

- 端口过滤

  - 输入命令 `sudo ufw enable && sudo ufw deny 80/tcp`
  - 再次执行attacker端的函数，进行抓包

  ![](img\status_change.png)

  ![](img\wireshark_res.png)

> 注意：此时抓包结果只有一个TCP 包，说明端口处于过滤状态

### TCP stealth scan

- 同上，在attacker端保存下列代码为可执行的python文件

  ```python
  from scapy.all import *
  
  def tcpstealthscan(dst_ip, dst_port, timeout=10):
      pkts = sr1(IP(dst=dst_ip)/TCP(dport=dst_port, flags="S"), timeout=10)
      if (pkts is None):
          print("Filtered")
      elif(pkts.haslayer(TCP)):
          if(pkts.getlayer(TCP).flags == 0x12):
              send_rst = sr(IP(dst=dst_ip) /
                            TCP(dport=dst_port, flags="R"), timeout=10)
              print("Open")
          elif (pkts.getlayer(TCP).flags == 0x14):
              print("Closed")
          elif(pkts.haslayer(ICMP)):
              if(int(pkts.getlayer(ICMP).type) == 3 and int(stealth_scan_resp.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]):
                  print("Filtered")
  
  
  tcpstealthscan('172.16.111.124', 80)
  ```

- 端口状态

  - 端口关闭 `sudo ufw disable`

    ![](img\port_close.png)

  - 端口打开`sudo ufw enable && sudo ufw allow 80/tcp`

    ![](img\port_open.png)

  - 端口过滤 `sudo ufw enable && sudo ufw deny 80/tcp`

    ![](img\port_deny.png)

### TCP Xmas scan

- 同上，在attacker端保存下列代码为可执行的python文件

  ```python
  from scapy.all import *
  
  def Xmasscan(dst_ip, dst_port, timeout=10):
      pkts = sr1(IP(dst=dst_ip)/TCP(dport=dst_port, flags="FPU"), timeout=10)
      if (pkts is None):
          print("Open|Filtered")
      elif(pkts.haslayer(TCP)):
          if(pkts.getlayer(TCP).flags == 0x14):
              print("Closed")
      elif(pkts.haslayer(ICMP)):
          if(int(pkts.getlayer(ICMP).type) == 3 and int(pkts.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]):
              print("Filtered")
  
  Xmasscan('172.16.111.124', 80)
  ```

- 端口状态

  - 端口关闭 `sudo ufw disable`

   ![](img\port_close_.png)

  - 端口打开`sudo ufw enable && sudo ufw allow 80/tcp`

  ![](img\port_open_.png)

  - 端口过滤 `sudo ufw enable && sudo ufw deny 80/tcp`

  ![](img\port_deny_.png)

  > 注意：对于xmass而言，当端口处于关闭状态时，则会回复一个RST包；其余所有状态都将不回复。

### TCP FIN scan

- 同上，在attacker端保存下列代码为可执行的python文件

  ```python
  from scapy.all import *
  
  def finscan(dst_ip, dst_port, timeout=10):
      pkts = sr1(IP(dst=dst_ip)/TCP(dport=dst_port, flags="F"), timeout=10)
      if (pkts is None):
          print("Open|Filtered")
      elif(pkts.haslayer(TCP)):
          if(pkts.getlayer(TCP).flags == 0x14):
              print("Closed")
      elif(pkts.haslayer(ICMP)):
          if(int(pkts.getlayer(ICMP).type) == 3 and int(pkts.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]):
              print("Filtered")
  
  finscan('172.16.111.124', 80)
  ```

- 端口状态

  - 端口关闭 `sudo ufw disable`

  ![](img\port_close1.png)

  - 端口打开`sudo ufw enable && sudo ufw allow 80/tcp`

  ![](img\port_open1.png)

  - 端口过滤 `sudo ufw enable && sudo ufw deny 80/tcp`

  ![](img\port_deny1.png)

> 注意：`FIN`数据包能够通过只监测`SYN`包的包过滤器，隐蔽性较`SYN`扫描更⾼，收到`RST`包说明端口处于关闭状态；反之说明为开启/过滤状态。

### TCP NULL scan

- 同上，在attacker端保存下列代码为可执行的python文件

  ```python
  #! /usr/bin/python
  from scapy.all import *
  
  def nullscan(dst_ip, dst_port, timeout=10):
      pkts = sr1(IP(dst=dst_ip)/TCP(dport=dst_port, flags=""), timeout=10)
      if (pkts is None):
          print("Open|Filtered")
      elif(pkts.haslayer(TCP)):
          if(pkts.getlayer(TCP).flags == 0x14):
              print("Closed")
      elif(pkts.haslayer(ICMP)):
          if(int(pkts.getlayer(ICMP).type) == 3 and int(pkts.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]):
              print("Filtered")
  
  nullscan('172.16.111.124', 80)
  ```

- 端口状态

  - 端口关闭 `sudo ufw disable`

  ![](img\port_close2.png)	

  - 端口打开`sudo ufw enable && sudo ufw allow 80/tcp`

  ![](img\port_open2.png)

  - 端口过滤 `sudo ufw enable && sudo ufw deny 80/tcp`

  ![](img\port_deny2.png)

> 注意：发送的包中关闭所有`TCP`报⽂头标记，收到`RST`包说明端口为关闭状态，未收到包即为开启/过滤状态。

### 总结与反思

- 安装ufw时，一直不成功，最后猛然想起来还有个 `sudo apt-get update`的操作，我有罪。

### 参考文献

​	[第五章 网络扫描 · 网络安全 (c4pr1c3.github.io)](https://c4pr1c3.github.io/cuc-ns/chap0x05/main.html)

​	[端口扫描 - Scapy_aFa攻防实验室的博客-CSDN博客_scapy 端口扫描](https://blog.csdn.net/fageweiketang/article/details/83963631)

​	[系统运维|Linux 防火墙 ufw 简介](https://linux.cn/article-12079-1.html)


